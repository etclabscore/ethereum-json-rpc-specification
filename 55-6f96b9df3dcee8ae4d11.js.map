{"version":3,"sources":["webpack:///./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js"],"names":["conf","comments","lineComment","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","indentationRules","increaseIndentPattern","RegExp","decreaseIndentPattern","language","tokenPostfix","keywords","keywordops","builtins","declarations","linedecls","operators","token","symbols","escape","escapes","decpart","decimal","delim","heredelim","regexpctl","regexpesc","tokenizer","root","cases","next","include","dodecl","switchTo","modifier","sstring","dstring","heredoc","interpolated","interpolated_compound","pregexp","regexp","regexcontrol","regexrange","regexpcomment","pstring","qstring","qqstring","whitespace","comment"],"mappings":"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","file":"55-6f96b9df3dcee8ae4d11.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport var conf = {\n  comments: {\n    lineComment: '#',\n    blockComment: ['=begin', '=end']\n  },\n  brackets: [['(', ')'], ['{', '}'], ['[', ']']],\n  autoClosingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }],\n  surroundingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }],\n  indentationRules: {\n    increaseIndentPattern: new RegExp('^\\\\s*((begin|class|(private|protected)\\\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\\\sdo\\\\b)|([^#]*=\\\\s*(case|if|unless)))\\\\b([^#\\\\{;]|(\"|\\'|\\/).*\\\\4)*(#.*)?$'),\n    decreaseIndentPattern: new RegExp('^\\\\s*([}\\\\]]([,)]?\\\\s*(#|$)|\\\\.[a-zA-Z_]\\\\w*\\\\b)|(end|rescue|ensure|else|elsif|when)\\\\b)')\n  }\n};\n/*\n * Ruby language definition\n *\n * Quite a complex language due to elaborate escape sequences\n * and quoting of literate strings/regular expressions, and\n * an 'end' keyword that does not always apply to modifiers like until and while,\n * and a 'do' keyword that sometimes starts a block, but sometimes is part of\n * another statement (like 'while').\n *\n * (1) end blocks:\n * 'end' may end declarations like if or until, but sometimes 'if' or 'until'\n * are modifiers where there is no 'end'. Also, 'do' sometimes starts a block\n * that is ended by 'end', but sometimes it is part of a 'while', 'for', or 'until'\n * To do proper brace matching we do some elaborate state manipulation.\n * some examples:\n *\n *   until bla do\n *     work until tired\n *     list.each do\n *       something if test\n *     end\n *   end\n *\n * or\n *\n * if test\n *  something (if test then x end)\n *  bar if bla\n * end\n *\n * or, how about using class as a property..\n *\n * class Test\n *   def endpoint\n *     self.class.endpoint || routes\n *   end\n * end\n *\n * (2) quoting:\n * there are many kinds of strings and escape sequences. But also, one can\n * start many string-like things as '%qx' where q specifies the kind of string\n * (like a command, escape expanded, regular expression, symbol etc.), and x is\n * some character and only another 'x' ends the sequence. Except for brackets\n * where the closing bracket ends the sequence.. and except for a nested bracket\n * inside the string like entity. Also, such strings can contain interpolated\n * ruby expressions again (and span multiple lines). Moreover, expanded\n * regular expression can also contain comments.\n */\n\nexport var language = {\n  tokenPostfix: '.ruby',\n  keywords: ['__LINE__', '__ENCODING__', '__FILE__', 'BEGIN', 'END', 'alias', 'and', 'begin', 'break', 'case', 'class', 'def', 'defined?', 'do', 'else', 'elsif', 'end', 'ensure', 'for', 'false', 'if', 'in', 'module', 'next', 'nil', 'not', 'or', 'redo', 'rescue', 'retry', 'return', 'self', 'super', 'then', 'true', 'undef', 'unless', 'until', 'when', 'while', 'yield'],\n  keywordops: ['::', '..', '...', '?', ':', '=>'],\n  builtins: ['require', 'public', 'private', 'include', 'extend', 'attr_reader', 'protected', 'private_class_method', 'protected_class_method', 'new'],\n  // these are closed by 'end' (if, while and until are handled separately)\n  declarations: ['module', 'class', 'def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'],\n  linedecls: ['def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'],\n  operators: ['^', '&', '|', '<=>', '==', '===', '!~', '=~', '>', '>=', '<', '<=', '<<', '>>', '+', '-', '*', '/', '%', '**', '~', '+@', '-@', '[]', '[]=', '`', '+=', '-=', '*=', '**=', '/=', '^=', '%=', '<<=', '>>=', '&=', '&&=', '||=', '|='],\n  brackets: [{\n    open: '(',\n    close: ')',\n    token: 'delimiter.parenthesis'\n  }, {\n    open: '{',\n    close: '}',\n    token: 'delimiter.curly'\n  }, {\n    open: '[',\n    close: ']',\n    token: 'delimiter.square'\n  }],\n  // we include these common regular expressions\n  symbols: /[=><!~?:&|+\\-*\\/\\^%\\.]+/,\n  // escape sequences\n  escape: /(?:[abefnrstv\\\\\"'\\n\\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,\n  escapes: /\\\\(?:C\\-(@escape|.)|c(@escape|.)|@escape)/,\n  decpart: /\\d(_?\\d)*/,\n  decimal: /0|@decpart/,\n  delim: /[^a-zA-Z0-9\\s\\n\\r]/,\n  heredelim: /(?:\\w+|'[^']*'|\"[^\"]*\"|`[^`]*`)/,\n  regexpctl: /[(){}\\[\\]\\$\\^|\\-*+?\\.]/,\n  regexpesc: /\\\\(?:[AzZbBdDfnrstvwWn0\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,\n  // The main tokenizer for our languages\n  tokenizer: {\n    // Main entry.\n    // root.<decl> where decl is the current opening declaration (like 'class')\n    root: [// identifiers and keywords\n    // most complexity here is due to matching 'end' correctly with declarations.\n    // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)\n    [/^(\\s*)([a-z_]\\w*[!?=]?)/, ['white', {\n      cases: {\n        'for|until|while': {\n          token: 'keyword.$2',\n          next: '@dodecl.$2'\n        },\n        '@declarations': {\n          token: 'keyword.$2',\n          next: '@root.$2'\n        },\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }]], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'if|unless|while|until': {\n          token: 'keyword.$0x',\n          next: '@modifier.$0x'\n        },\n        'for': {\n          token: 'keyword.$2',\n          next: '@dodecl.$2'\n        },\n        '@linedecls': {\n          token: 'keyword.$0',\n          next: '@root.$0'\n        },\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], [/[A-Z][\\w]*[!?=]?/, 'constructor.identifier'], [/\\$[\\w]*/, 'global.constant'], [/@[\\w]*/, 'namespace.instance.identifier'], [/@@[\\w]*/, 'namespace.class.identifier'], // here document\n    [/<<[-~](@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], [/[ \\t\\r\\n]+<<(@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], [/^<<(@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], // whitespace\n    {\n      include: '@whitespace'\n    }, // strings\n    [/\"/, {\n      token: 'string.d.delim',\n      next: '@dstring.d.\"'\n    }], [/'/, {\n      token: 'string.sq.delim',\n      next: '@sstring.sq'\n    }], // % literals. For efficiency, rematch in the 'pstring' state\n    [/%([rsqxwW]|Q?)/, {\n      token: '@rematch',\n      next: 'pstring'\n    }], // commands and symbols\n    [/`/, {\n      token: 'string.x.delim',\n      next: '@dstring.x.`'\n    }], [/:(\\w|[$@])\\w*[!?=]?/, 'string.s'], [/:\"/, {\n      token: 'string.s.delim',\n      next: '@dstring.s.\"'\n    }], [/:'/, {\n      token: 'string.s.delim',\n      next: '@sstring.s'\n    }], // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line\n    [/\\/(?=(\\\\\\/|[^\\/\\n])+\\/)/, {\n      token: 'regexp.delim',\n      next: '@regexp'\n    }], // delimiters and operators\n    [/[{}()\\[\\]]/, '@brackets'], [/@symbols/, {\n      cases: {\n        '@keywordops': 'keyword',\n        '@operators': 'operator',\n        '@default': ''\n      }\n    }], [/[;,]/, 'delimiter'], // numbers\n    [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, 'number.hex'], [/0[_oO][0-7](_?[0-7])*/, 'number.octal'], [/0[bB][01](_?[01])*/, 'number.binary'], [/0[dD]@decpart/, 'number'], [/@decimal((\\.@decpart)?([eE][\\-+]?@decpart)?)/, {\n      cases: {\n        '$1': 'number.float',\n        '@default': 'number'\n      }\n    }]],\n    // used to not treat a 'do' as a block opener if it occurs on the same\n    // line as a 'do' statement: 'while|until|for'\n    // dodecl.<decl> where decl is the declarations started, like 'while'\n    dodecl: [[/^/, {\n      token: '',\n      switchTo: '@root.$S2'\n    }], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        'do': {\n          token: 'keyword',\n          switchTo: '@root.$S2'\n        },\n        '@linedecls': {\n          token: '@rematch',\n          switchTo: '@root.$S2'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], {\n      include: '@root'\n    }],\n    // used to prevent potential modifiers ('if|until|while|unless') to match\n    // with 'end' keywords.\n    // modifier.<decl>x where decl is the declaration starter, like 'if'\n    modifier: [[/^/, '', '@pop'], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        'then|else|elsif|do': {\n          token: 'keyword',\n          switchTo: '@root.$S2'\n        },\n        '@linedecls': {\n          token: '@rematch',\n          switchTo: '@root.$S2'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], {\n      include: '@root'\n    }],\n    // single quote strings (also used for symbols)\n    // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)\n    sstring: [[/[^\\\\']+/, 'string.$S2'], [/\\\\\\\\|\\\\'|\\\\$/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.invalid'], [/'/, {\n      token: 'string.$S2.delim',\n      next: '@pop'\n    }]],\n    // double quoted \"string\".\n    // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)\n    // and delim is the ending delimiter (\" or `)\n    dstring: [[/[^\\\\`\"#]+/, 'string.$S2'], [/#/, 'string.$S2.escape', '@interpolated'], [/\\\\$/, 'string.$S2.escape'], [/@escapes/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.escape.invalid'], [/[`\"]/, {\n      cases: {\n        '$#==$S3': {\n          token: 'string.$S2.delim',\n          next: '@pop'\n        },\n        '@default': 'string.$S2'\n      }\n    }]],\n    // literal documents\n    // heredoc.<close> where close is the closing delimiter\n    heredoc: [[/^(\\s*)(@heredelim)$/, {\n      cases: {\n        '$2==$S2': ['string.heredoc', {\n          token: 'string.heredoc.delimiter',\n          next: '@pop'\n        }],\n        '@default': ['string.heredoc', 'string.heredoc']\n      }\n    }], [/.*/, 'string.heredoc']],\n    // interpolated sequence\n    interpolated: [[/\\$\\w*/, 'global.constant', '@pop'], [/@\\w*/, 'namespace.class.identifier', '@pop'], [/@@\\w*/, 'namespace.instance.identifier', '@pop'], [/[{]/, {\n      token: 'string.escape.curly',\n      switchTo: '@interpolated_compound'\n    }], ['', '', '@pop']],\n    // any code\n    interpolated_compound: [[/[}]/, {\n      token: 'string.escape.curly',\n      next: '@pop'\n    }], {\n      include: '@root'\n    }],\n    // %r quoted regexp\n    // pregexp.<open>.<close> where open/close are the open/close delimiter\n    pregexp: [{\n      include: '@whitespace'\n    }, // turns out that you can quote using regex control characters, aargh!\n    // for example; %r|kgjgaj| is ok (even though | is used for alternation)\n    // so, we need to match those first\n    [/[^\\(\\{\\[\\\\]/, {\n      cases: {\n        '$#==$S3': {\n          token: 'regexp.delim',\n          next: '@pop'\n        },\n        '$#==$S2': {\n          token: 'regexp.delim',\n          next: '@push'\n        },\n        '~[)}\\\\]]': '@brackets.regexp.escape.control',\n        '~@regexpctl': 'regexp.escape.control',\n        '@default': 'regexp'\n      }\n    }], {\n      include: '@regexcontrol'\n    }],\n    // We match regular expression quite precisely\n    regexp: [{\n      include: '@regexcontrol'\n    }, [/[^\\\\\\/]/, 'regexp'], ['/[ixmp]*', {\n      token: 'regexp.delim'\n    }, '@pop']],\n    regexcontrol: [[/(\\{)(\\d+(?:,\\d*)?)(\\})/, ['@brackets.regexp.escape.control', 'regexp.escape.control', '@brackets.regexp.escape.control']], [/(\\[)(\\^?)/, ['@brackets.regexp.escape.control', {\n      token: 'regexp.escape.control',\n      next: '@regexrange'\n    }]], [/(\\()(\\?[:=!])/, ['@brackets.regexp.escape.control', 'regexp.escape.control']], [/\\(\\?#/, {\n      token: 'regexp.escape.control',\n      next: '@regexpcomment'\n    }], [/[()]/, '@brackets.regexp.escape.control'], [/@regexpctl/, 'regexp.escape.control'], [/\\\\$/, 'regexp.escape'], [/@regexpesc/, 'regexp.escape'], [/\\\\\\./, 'regexp.invalid'], [/#/, 'regexp.escape', '@interpolated']],\n    regexrange: [[/-/, 'regexp.escape.control'], [/\\^/, 'regexp.invalid'], [/\\\\$/, 'regexp.escape'], [/@regexpesc/, 'regexp.escape'], [/[^\\]]/, 'regexp'], [/\\]/, '@brackets.regexp.escape.control', '@pop']],\n    regexpcomment: [[/[^)]+/, 'comment'], [/\\)/, {\n      token: 'regexp.escape.control',\n      next: '@pop'\n    }]],\n    // % quoted strings\n    // A bit repetitive since we need to often special case the kind of ending delimiter\n    pstring: [[/%([qws])\\(/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.(.)'\n    }], [/%([qws])\\[/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.[.]'\n    }], [/%([qws])\\{/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.{.}'\n    }], [/%([qws])</, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.<.>'\n    }], [/%([qws])(@delim)/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.$2.$2'\n    }], [/%r\\(/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.(.)'\n    }], [/%r\\[/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.[.]'\n    }], [/%r\\{/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.{.}'\n    }], [/%r</, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.<.>'\n    }], [/%r(@delim)/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.$1.$1'\n    }], [/%(x|W|Q?)\\(/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.(.)'\n    }], [/%(x|W|Q?)\\[/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.[.]'\n    }], [/%(x|W|Q?)\\{/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.{.}'\n    }], [/%(x|W|Q?)</, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.<.>'\n    }], [/%(x|W|Q?)(@delim)/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.$2.$2'\n    }], [/%([rqwsxW]|Q?)./, {\n      token: 'invalid',\n      next: '@pop'\n    }], [/./, {\n      token: 'invalid',\n      next: '@pop'\n    }]],\n    // non-expanded quoted string.\n    // qstring.<kind>.<open>.<close>\n    //  kind = q|w|s  (single quote, array, symbol)\n    //  open = open delimiter\n    //  close = close delimiter\n    qstring: [[/\\\\$/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.escape'], [/./, {\n      cases: {\n        '$#==$S4': {\n          token: 'string.$S2.delim',\n          next: '@pop'\n        },\n        '$#==$S3': {\n          token: 'string.$S2.delim',\n          next: '@push'\n        },\n        '@default': 'string.$S2'\n      }\n    }]],\n    // expanded quoted string.\n    // qqstring.<kind>.<open>.<close>\n    //  kind = Q|W|x  (double quote, array, command)\n    //  open = open delimiter\n    //  close = close delimiter\n    qqstring: [[/#/, 'string.$S2.escape', '@interpolated'], {\n      include: '@qstring'\n    }],\n    // whitespace & comments\n    whitespace: [[/[ \\t\\r\\n]+/, ''], [/^\\s*=begin\\b/, 'comment', '@comment'], [/#.*$/, 'comment']],\n    comment: [[/[^=]+/, 'comment'], [/^\\s*=begin\\b/, 'comment.invalid'], [/^\\s*=end\\b.*/, 'comment', '@pop'], [/[=]/, 'comment']]\n  }\n};"],"sourceRoot":""}